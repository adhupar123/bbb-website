<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Simulator — BBB Diffusion (Simple)</title>
  <link rel="stylesheet" href="styles.css" />
  <style>
    .simcard{padding:12px}
    #simCanvas{width:100%;height:420px;border-radius:10px;background:#fff;border:1px solid #e6edf8; display:block}
    label{font-weight:600;display:block;margin-top:10px}
    .small{font-size:13px;color:#6b7280}
    .controls{max-width:420px}
  </style>
</head>
<body>
  <header class="navwrap"><div class="container topbar"><div class="brand"><h1>Interactive Simulator</h1><div class="muted">Simple visual model with equilibrium</div></div>
  <nav class="mainnav"><a href="index.html">Home</a></nav></div></header>

  <main class="container">
    <section class="card simcard">
      <h2>BBB Diffusion — Equilibrium Visualizer</h2>
      <p class="small">Three sliders: <strong>radius</strong>, <strong>LogBB</strong>, and <strong>charge</strong>. Particles can cross in both directions, establishing an equilibrium across the BBB.</p>

      <canvas id="simCanvas"></canvas>

      <div style="display:flex;gap:20px;margin-top:12px;flex-wrap:wrap">
        <div class="controls">
          <label>Particle radius (nm): <span id="radLabel">40</span></label>
          <input id="radSlider" type="range" min="5" max="150" value="40">

          <label>LogBB value: <span id="logbbLabel">-1.0</span></label>
          <input id="logbb" type="range" min="-1.5" max="1.0" step="0.1" value="-1.0">

          <label>Charge</label>
          <select id="charge">
            <option value="neutral">Neutral</option>
            <option value="positive">Positive</option>
            <option value="negative">Negative</option>
          </select>

          <div style="margin-top:10px">
            <a id="startBtn" class="btn">Start</a>
            <a id="resetBtn" class="btn ghost">Reset</a>
          </div>

          <p class="small">Bloodstream: <span id="bloodCount">400</span> | Brain: <span id="brainCount">0</span></p>
        </div>
      </div>
    </section>
  </main>

<script>
const canvas = document.getElementById('simCanvas');
const ctx = canvas.getContext('2d');

function fitCanvas(){
  const DPR = window.devicePixelRatio || 1;
  const rect = canvas.getBoundingClientRect();
  canvas.width = Math.floor(rect.width * DPR);
  canvas.height = Math.floor(rect.height * DPR);
  ctx.setTransform(DPR,0,0,DPR,0,0);
}
window.addEventListener('resize', fitCanvas);
fitCanvas();

const NUM = 400;
const FIXED_D = 5;
const FIXED_PERM = 0.06;

let particles = [];
let running = false;

const radSlider = document.getElementById('radSlider');
const radLabel = document.getElementById('radLabel');
const logbb = document.getElementById('logbb');
const logbbLabel = document.getElementById('logbbLabel');
const charge = document.getElementById('charge');
const startBtn = document.getElementById('startBtn');
const resetBtn = document.getElementById('resetBtn');
const bloodCountEl = document.getElementById('bloodCount');
const brainCountEl = document.getElementById('brainCount');

radSlider.oninput = e => radLabel.textContent = e.target.value;
logbb.oninput = e => logbbLabel.textContent = e.target.value;

function rand(a,b){return a + Math.random()*(b-a);} 

function init(){
  particles = [];
  const rpx = Math.max(2, Number(radSlider.value) / 20);
  const w = canvas.clientWidth;
  const h = canvas.clientHeight;
  
  // All particles start in bloodstream (left side)
  for(let i=0;i<NUM;i++){ 
    particles.push({
      x: rand(rpx + 8, w/2 - 30),
      y: rand(rpx + 8, h - rpx - 8),
      r: rpx,
      inBrain: false,
      justCrossed: false  // cooldown to prevent instant re-crossing
    });
  }
  updateCounts();
}

function updateCounts(){
  const w = canvas.clientWidth;
  const bx = w/2;
  
  // Count based on actual position relative to barrier
  let inBrain = 0;
  let inBlood = 0;
  
  for(const p of particles){
    if(p.x > bx){
      inBrain++;
    } else {
      inBlood++;
    }
  }
  
  bloodCountEl.textContent = inBlood;
  brainCountEl.textContent = inBrain;
}

function drawBackground(){
  const w = canvas.clientWidth, h = canvas.clientHeight;
  ctx.fillStyle = '#fff';
  ctx.fillRect(0,0,w,h);
  
  // barrier line
  ctx.fillStyle = '#0b5fff';
  ctx.fillRect(w/2 - 3, 0, 6, h);
  
  // labels
  ctx.fillStyle = '#223';
  ctx.font = '12px system-ui, Arial';
  ctx.fillText('Bloodstream', 10, 16);
  ctx.fillText('Brain', w - 60, 16);
}

function step(dt){
  const rnm = Number(radSlider.value);
  const logbbVal = Number(logbb.value);
  const chargeMode = charge.value;

  const w = canvas.clientWidth, h = canvas.clientHeight;
  const bx = w/2;

  // Calculate crossing probability factors
  const t = Math.min(1, Math.max(0, (logbbVal + 1.5) / 2.5));
  const logbbEffect = 0.4 * t + 0.6;
  const sizeFactor = Math.max(0.05, 1 - (rnm / 200));
  
  // Base crossing probability
  const baseCrossProb = FIXED_PERM * sizeFactor;
  
  // LogBB affects the ratio of blood->brain vs brain->blood crossing
  // Positive LogBB: easier to enter brain, harder to leave
  // Negative LogBB: harder to enter brain, easier to leave
  const bloodToBrainProb = baseCrossProb * logbbEffect;
  const brainToBloodProb = baseCrossProb * (2 - logbbEffect); // inverse relationship

  for(const p of particles){
    // Reset justCrossed flag if particle has moved away from barrier
    const distToBarrier = Math.abs(p.x - bx);
    if(p.justCrossed && distToBarrier > p.r + 15){
      p.justCrossed = false;
    }

    // Diffusion movement
    const dx = rand(-1,1) * FIXED_D * dt * 18;
    const dy = rand(-1,1) * FIXED_D * dt * 18;
    
    p.x += dx;
    p.y += dy;

    // Small charge bias
    if(chargeMode === 'positive') p.x += 0.4;
    if(chargeMode === 'negative') p.x -= 0.4;

    // Keep particles in vertical bounds (bounce)
    if(p.y - p.r < 4){
      p.y = p.r + 4;
    }
    if(p.y + p.r > h - 4){
      p.y = h - p.r - 4;
    }

    // Keep particles in horizontal bounds (bounce off walls, not barrier)
    if(p.x - p.r < 4){
      p.x = p.r + 4;
    }
    if(p.x + p.r > w - 4){
      p.x = w - p.r - 4;
    }

    // Update which side particle is on
    const wasInBrain = p.inBrain;
    p.inBrain = (p.x > bx);

    // Check for barrier interaction - only if not just crossed
    if(!p.justCrossed && distToBarrier < p.r + 3){
      // Determine which direction we're trying to cross
      const crossingToBrain = (p.x < bx);
      const crossProb = crossingToBrain ? bloodToBrainProb : brainToBloodProb;
      
      // Attempt crossing
      if(Math.random() < crossProb){
        // Successfully cross to the other side
        if(crossingToBrain){
          // Crossing from blood to brain (left to right)
          p.x = bx + p.r + 8;
          p.inBrain = true;
        } else {
          // Crossing from brain to blood (right to left)
          p.x = bx - p.r - 8;
          p.inBrain = false;
        }
        p.justCrossed = true;
      } else {
        // Failed to cross - bounce back
        if(crossingToBrain){
          // Bounce back into bloodstream
          p.x = bx - p.r - 8;
          p.inBrain = false;
        } else {
          // Bounce back into brain
          p.x = bx + p.r + 8;
          p.inBrain = true;
        }
      }
    }
  }
  
  updateCounts();
}

function render(){
  drawBackground();
  
  const logbbVal = Number(logbb.value);
  const t = Math.min(1, Math.max(0, (logbbVal + 1.5) / 2.5));
  const w = canvas.clientWidth;
  const bx = w/2;
  
  for(const p of particles){
    ctx.beginPath();
    
    // Color based on which side of barrier (actual position)
    if(p.x > bx){
      // In brain - green
      ctx.fillStyle = 'rgba(34,197,94,0.85)';
    } else {
      // In bloodstream - original color gradient based on logBB
      const r = Math.round(220 * t + 10 * (1 - t));
      const b = Math.round(220 * (1 - t) + 10 * t);
      ctx.fillStyle = `rgb(${r},80,${b})`;
    }
    
    ctx.arc(p.x, p.y, p.r, 0, Math.PI*2);
    ctx.fill();
  }
}

let lastTime = null;
function loop(now){
  if(!running) return;
  if(!lastTime) lastTime = now;
  const dt = Math.min(0.05, (now - lastTime)/1000);
  lastTime = now;
  step(dt);
  render();
  requestAnimationFrame(loop);
}

startBtn.addEventListener('click', ()=>{
  if(!running){
    running = true;
    lastTime = null;
    requestAnimationFrame(loop);
  }
});

resetBtn.addEventListener('click', ()=>{
  running = false;
  init();
  render();
});

init();
render();
</script>
</body>
</html>
