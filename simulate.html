<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Simulator — BBB Diffusion (Simple)</title>
  <link rel="stylesheet" href="styles.css" />
  <style>
    /* quick overrides for simulator */
    .simcard{padding:12px}
    #simCanvas{width:100%;height:420px;border-radius:10px;background:#fff;border:1px solid #e6edf8; display:block}
    label{font-weight:600;display:block;margin-top:10px}
    .small{font-size:13px;color:#6b7280}
    .controls{max-width:420px}
  </style>
</head>
<body>
  <header class="navwrap"><div class="container topbar"><div class="brand"><h1>Interactive Simulator</h1><div class="muted">Simple visual model</div></div>
  <nav class="mainnav"><a href="index.html">Home</a></nav></div></header>

  <main class="container">
    <section class="card simcard">
      <h2>BBB Diffusion — Simple Visualizer</h2>
      <p class="small">Three sliders: <strong>radius</strong>, <strong>LogBB</strong>, and <strong>charge</strong>. Everything else is fixed for clarity.</p>

      <canvas id="simCanvas"></canvas>

      <div style="display:flex;gap:20px;margin-top:12px;flex-wrap:wrap">
        <div class="controls">
          <label>Particle radius (nm): <span id="radLabel">40</span></label>
          <input id="radSlider" type="range" min="5" max="150" value="40">

          <label>LogBB value: <span id="logbbLabel">-1.0</span></label>
          <input id="logbb" type="range" min="-1.5" max="1.0" step="0.1" value="-1.0">

          <label>Charge</label>
          <select id="charge">
            <option value="neutral">Neutral</option>
            <option value="positive">Positive</option>
            <option value="negative">Negative</option>
          </select>

          <div style="margin-top:10px">
            <a id="startBtn" class="btn">Start</a>
            <a id="resetBtn" class="btn ghost">Reset</a>
          </div>

          <p class="small">Crossed: <span id="crossed">0</span> / <span id="total">0</span></p>
        </div>
      </div>
    </section>
  </main>

<script>
// Simple educational simulator — minimal, stable settings.
const canvas = document.getElementById('simCanvas');
const ctx = canvas.getContext('2d');

// Fit canvas to displayed size (pixel ratio)
function fitCanvas(){
  const DPR = window.devicePixelRatio || 1;
  const rect = canvas.getBoundingClientRect();
  canvas.width = Math.floor(rect.width * DPR);
  canvas.height = Math.floor(rect.height * DPR);
  ctx.setTransform(DPR,0,0,DPR,0,0);
}
window.addEventListener('resize', fitCanvas);
fitCanvas();

const NUM = 400;       // fixed particle count
const FIXED_D = 5;     // fixed diffusion coefficient (visual)
const FIXED_PERM = 0.06; // fixed permeability

let particles = [];
let running = false;
let crossed = 0;

// UI elements
const radSlider = document.getElementById('radSlider');
const radLabel = document.getElementById('radLabel');
const logbb = document.getElementById('logbb');
const logbbLabel = document.getElementById('logbbLabel');
const charge = document.getElementById('charge');
const startBtn = document.getElementById('startBtn');
const resetBtn = document.getElementById('resetBtn');
const crossedEl = document.getElementById('crossed');
const totalEl = document.getElementById('total');

// labels
radSlider.oninput = e => radLabel.textContent = e.target.value;
logbb.oninput = e => logbbLabel.textContent = e.target.value;

// helpers
function rand(a,b){return a + Math.random()*(b-a);}

// initialize particles
function init(){
  particles = [];
  crossed = 0;
  const rpx = Math.max(2, Number(radSlider.value) / 20);
  const w = canvas.clientWidth;
  const h = canvas.clientHeight;
  for(let i=0;i<NUM;i++){ 
    particles.push({
      x: rand(8, w/2 - 30),
      y: rand(8, h - 8),
      r: rpx,
      crossed: false
    });
  }
  crossedEl.textContent = crossed;
  totalEl.textContent = NUM;
}

// draw background
function drawBackground(){
  const w = canvas.clientWidth, h = canvas.clientHeight;
  // clear
  ctx.fillStyle = '#fff';
  ctx.fillRect(0,0,w,h);
  // barrier
  ctx.fillStyle = '#0b5fff';
  ctx.fillRect(w/2 - 3, 0, 6, h);
  // labels
  ctx.fillStyle = '#223';
  ctx.font = '12px system-ui, Arial';
  ctx.fillText('Bloodstream', 10, 16);
  ctx.fillText('Brain', w - 60, 16);
}

// step
function step(dt){
  const rnm = Number(radSlider.value);
  const logbbVal = Number(logbb.value);
  const chargeMode = charge.value;

  const w = canvas.clientWidth, h = canvas.clientHeight;
  const bx = w/2;

  for(const p of particles){
    if(p.crossed) continue;
    // diffusion step (visual scaling)
    p.x += rand(-1,1) * FIXED_D * dt * 18;
    p.y += rand(-1,1) * FIXED_D * dt * 18;

    // charge bias (small)
    if(chargeMode === 'positive') p.x += 0.4;
    if(chargeMode === 'negative') p.x -= 0.4;

    // keep in bounds vertically
    if(p.y < p.r + 4) p.y = p.r + 4;
    if(p.y > h - (p.r + 4)) p.y = h - (p.r + 4);

    // barrier interaction
    if(!p.crossed && p.x > bx - (p.r + 2)){
      // crossing probability affected by LogBB (higher LogBB -> more likely)
      // Map logBB -1.5..1.0 to 0..1
      const t = Math.min(1, Math.max(0, (logbbVal + 1.5) / 2.5));
      const logbbEffect = 0.4 * t + 0.6; // between 0.6 and 1.0
      // size effect (larger radius makes crossing less probable)
      const sizeFactor = Math.max(0.05, 1 - (rnm / 200));
      const prob = FIXED_PERM * logbbEffect * sizeFactor;
      if(Math.random() < prob){
        p.crossed = true;
        crossed++;
      } else {
        p.x = bx - (p.r + 6);
      }
    }

    // wall limits
    if(p.x < 4) p.x = 4;
    if(p.x > w - 4) p.x = w - 4;
  }
  crossedEl.textContent = crossed;
}

// render
function render(){
  drawBackground();
  for(const p of particles){
    // color by logBB (low: bluish, high: reddish)
    const t = Math.min(1, Math.max(0, (Number(logbb.value) + 1.5) / 2.5));
    const r = Math.round(220 * t + 10 * (1 - t));
    const b = Math.round(220 * (1 - t) + 10 * t);
    ctx.beginPath();
    ctx.fillStyle = p.crossed ? 'rgba(11,95,255,0.95)' : `rgb(${r},80,${b})`;
    ctx.arc(p.x, p.y, p.r, 0, Math.PI*2);
    ctx.fill();
  }
}

// animation loop
let lastTime = null;
function loop(now){
  if(!running) return;
  if(!lastTime) lastTime = now;
  const dt = Math.min(0.05, (now - lastTime)/1000);
  lastTime = now;
  step(dt);
  render();
  requestAnimationFrame(loop);
}

// UI wiring
startBtn.addEventListener('click', ()=>{
  if(!running){
    running = true;
    lastTime = null;
    requestAnimationFrame(loop);
  }
});
resetBtn.addEventListener('click', ()=>{
  running = false;
  init();
  render();
});

// initial setup
init();
render();
</script>
</body>
</html>